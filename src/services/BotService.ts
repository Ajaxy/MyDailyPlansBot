import { Bot, GrammyError, HttpError } from 'grammy';
import { SchedulerService } from './SchedulerService';
import { UserService } from './UserService';
import { PlanService } from './PlanService';
import { ReminderService } from './ReminderService';
import { DutyReminderService } from './DutyReminderService';
import { OffService } from './OffService';
import { BotConfig } from '../types';
import { User } from '../entities';

export class BotService {
  private bot: Bot;
  private planService: PlanService;
  private reminderService: ReminderService;
  private scheduler: SchedulerService;
  private userService: UserService;
  private dutyReminderService: DutyReminderService;
  private offService: OffService;
  private config: BotConfig;

  constructor(config: BotConfig) {
    this.config = config;
    this.bot = new Bot(config.token);
    this.planService = new PlanService();
    this.reminderService = new ReminderService();
    this.userService = new UserService();
    this.offService = new OffService();
    this.dutyReminderService = new DutyReminderService(this.bot, this.userService);
    this.scheduler = new SchedulerService(this.bot,
      this.planService,
      this.reminderService,
      this.userService,
      this.dutyReminderService);

    this.setupHandlers();
    this.setupErrorHandling();
  }

  public async start(): Promise<void> {
    console.log('Starting MyDailyPlans bot...');

    try {
      const activeChatIds = await this.userService.getActiveChatIds();
      console.log(`Active chats configured: ${activeChatIds.join(', ')}`);
    } catch (error) {
      console.log('No active chats found in database');
    }

    // Start the scheduler
    this.scheduler.start();

    // Start the bot
    await this.bot.start();
    console.log('MyDailyPlans bot started successfully');
  }

  public async stop(): Promise<void> {
    console.log('Stopping MyDailyPlans bot...');
    await this.bot.stop();
    console.log('MyDailyPlans bot stopped');
  }

  // For testing purposes
  public getBot(): Bot {
    return this.bot;
  }

  public getPlanService(): PlanService {
    return this.planService;
  }

  public getReminderService(): ReminderService {
    return this.reminderService;
  }

  public getScheduler(): SchedulerService {
    return this.scheduler;
  }

  public getUserService(): UserService {
    return this.userService;
  }

  // For manual reminder triggering in development
  public async triggerReminder(hour?: number): Promise<void> {
    console.log('Manually triggering reminders...');
    const scheduler = this.getScheduler();

    // Use provided hour or current time to determine reminder type
    const targetHour = hour !== undefined ? hour : new Date().getHours();

    if (targetHour === 6) {
      // Trigger initial reminder
      console.log('Triggering initial reminder (6 AM type)');
      await scheduler.sendInitialReminder();
    } else {
      // Trigger follow-up reminder
      console.log('Triggering follow-up reminder');
      await scheduler.sendFollowUpReminder();
    }
  }

  // For manual PR reminder triggering in development
  public async triggerPrReminder(): Promise<void> {
    console.log('Manually triggering PR reminders...');
    const scheduler = this.getScheduler();
    await scheduler.sendPrReminders();
  }

  // For manual duty reminder triggering in development
  public async triggerDutyReminder(): Promise<void> {
    console.log('Manually triggering duty reminders...');
    await this.dutyReminderService.sendDutyReminders();
  }

  private setupHandlers(): void {
    // Handle when bot is added to/removed from a group (informational only)
    this.bot.on('my_chat_member', async (ctx) => {
      const chatMember = ctx.myChatMember;
      const chat = ctx.chat;

      if (chatMember.new_chat_member.status === 'member' || chatMember.new_chat_member.status === 'administrator') {
        console.log(`Bot added to chat: ${chat.id} (${chat.title || 'Private chat'})`);

        await ctx.reply(
          'üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç *MyDailyPlans*, –ø–æ–º–æ–≥–∞—é –≤—Å–µ–º –±—ã—Ç—å –≤ –∫—É—Ä—Å–µ –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –ø–ª–∞–Ω–æ–≤ –∫–æ–º–∞–Ω–¥—ã.' +
          '\n\n–ë—É–¥—É –Ω–∞–ø–æ–º–∏–Ω–∞—Ç—å —Ä–∞—Å—Å–∫–∞–∑—ã–≤–∞—Ç—å –æ –ø–ª–∞–Ω–∞—Ö –Ω–∞ –¥–µ–Ω—å: –≤ —Ä–∞–±–æ—á–∏–µ –¥–Ω–∏ –≤ 6:00 GMT, —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è–º–∏ –¥–æ 15:00 GMT.' +
          '\n\n*–ö–æ–º–∞–Ω–¥—ã:*' +
          '\n/status - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –æ—Ç–≤–µ—Ç–æ–≤' +
          '\n/remind_pr - –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ PR' +
          '\n/help - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø—Ä–∞–≤–∫—É',
          { parse_mode: 'Markdown' },
        );
      } else if (chatMember.new_chat_member.status === 'left' || chatMember.new_chat_member.status === 'kicked') {
        console.log(`Bot removed from chat: ${chat.id}`);
      }
    });

    // Handle /status command to check who has replied
    this.bot.command('status', async (ctx) => {
      if (ctx.chat.type === 'private') {
        await ctx.reply('–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö.');
        return;
      }

      const chatId = ctx.chat.id;

      try {
        const trackedUsers = await this.userService.getActiveUsersForChat(chatId);

        if (trackedUsers.length === 0) {
          await ctx.reply(
            '‚ö†Ô∏è –í —ç—Ç–æ–º —á–∞—Ç–µ –Ω–µ—Ç –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.\n\n' +
            '–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –∫–æ–º–∞–Ω–¥—ã.',
          );
          return;
        }

        const date = this.getCurrentDate();
        const repliedUserIds = await this.planService.getRepliedUserIds(chatId, date);
        const trackedUserIds = trackedUsers.map((u: User) => u.telegramId);
        const unrepliedUserIds = await this.planService.getUnrepliedUserIds(chatId, date, trackedUserIds);
        const reminderCount = await this.reminderService.getReminderCount(chatId, date);

        let statusMessage = `üìä –°—Ç–∞—Ç—É—Å –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –ø–ª–∞–Ω–æ–≤ –Ω–∞ ${date}:`;
        statusMessage += `\n\n‚è∞ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π: ${reminderCount}/4`;
        statusMessage += `\n‚úÖ –û—Ç–≤–µ—Ç–∏–ª–∏: ${repliedUserIds.length}/${trackedUsers.length}`;

        if (unrepliedUserIds.length > 0) {
          statusMessage += `\n‚è≥ –û–∂–∏–¥–∞–µ–º –æ—Ç–≤–µ—Ç–æ–≤: ${unrepliedUserIds.length}`;
        } else {
          statusMessage += '\nüéâ –í—Å–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏ –∫–æ–º–∞–Ω–¥—ã –æ—Ç–≤–µ—Ç–∏–ª–∏!';
        }

        await ctx.reply(statusMessage, { parse_mode: 'Markdown' });
      } catch (error) {
        console.error('Error getting status:', error);
        await ctx.reply('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞.');
      }
    });

    // Handle /remind_pr command to manually trigger PR reminders
    this.bot.command('remind_pr', async (ctx) => {
      if (ctx.chat.type === 'private') {
        await ctx.reply('–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö.');
        return;
      }

      const chatId = ctx.chat.id;

      try {
        await ctx.reply('üîÑ –ü—Ä–æ–≤–µ—Ä—è—é PR –¥–ª—è —ç—Ç–æ–≥–æ —á–∞—Ç–∞...');

        // Send PR reminder only for this specific chat
        const prReminderService = this.scheduler.getPrReminderService();
        await prReminderService.sendPrReminderToChat(chatId);

        // Note: Success/no PRs message will be sent by the PR reminder service itself
      } catch (error) {
        console.error('Error sending PR reminders:', error);
        await ctx.reply('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –æ PR.');
      }
    });

    // Handle /remind_duty command to manually trigger duty reminders
    this.bot.command('remind_duty', async (ctx) => {
      if (ctx.chat.type === 'private') {
        await ctx.reply('–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö.');
        return;
      }

      const chatId = ctx.chat.id;

      // Only allow in the specific duty chat
      if (chatId !== -1001783045675) {
        await ctx.reply('–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ –¥–µ–∂—É—Ä—Å—Ç–≤–µ –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ –≤ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–º —á–∞—Ç–µ.');
        return;
      }

      try {
        await ctx.reply('üîÑ –ü—Ä–æ–≤–µ—Ä—è—é –¥–µ–∂—É—Ä—Å—Ç–≤–æ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è...');

        // Send duty reminder only for this specific chat
        await this.dutyReminderService.sendDutyReminderToChat(chatId);

      } catch (error) {
        console.error('Error sending duty reminder:', error);
        await ctx.reply('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ –¥–µ–∂—É—Ä—Å—Ç–≤–µ.');
      }
    });

    // Handle /off command to register user's absence
    this.bot.command('off', async (ctx) => {
      if (ctx.chat.type === 'private') {
        await ctx.reply('–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö.');
        return;
      }

      const chatId = ctx.chat.id;
      const commandText = ctx.message?.text || '';
      const parts = commandText.split(' ').slice(1); // Remove /off

      try {
        // Parse the command arguments
        let username: string | undefined;
        let dateRange: string;

        // Check if first argument is a username (starts with @)
        if (parts.length > 0 && parts[0].startsWith('@')) {
          username = parts[0].substring(1); // Remove @ symbol
          dateRange = parts.slice(1).join(' ');
        } else {
          // No username specified, use current sender
          username = ctx.from?.username;
          dateRange = parts.join(' ');
        }

        if (!username) {
          await ctx.reply('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —É –≤–∞—Å –µ—Å—Ç—å username –≤ Telegram.');
          return;
        }

        // Find the user in the database
        const user = await this.userService.getUserByUsernameAndChat(username, chatId);
        if (!user) {
          await ctx.reply(`‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å @${username} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —ç—Ç–æ–º —á–∞—Ç–µ. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω.`);
          return;
        }

        // Parse dates
        let fromDate: Date;
        let toDate: Date;

        if (!dateRange || dateRange.trim() === '') {
          // No dates specified, default to today
          fromDate = new Date();
          toDate = new Date();
          fromDate.setHours(0, 0, 0, 0);
          toDate.setHours(0, 0, 0, 0);
        } else if (dateRange.includes('-')) {
          // Date range specified
          const [fromStr, toStr] = dateRange.split('-').map(s => s.trim());
          
          if (!fromStr || fromStr === '') {
            // Only end date specified, start from today
            fromDate = new Date();
            fromDate.setHours(0, 0, 0, 0);
          } else {
            const parsedFrom = this.parseDate(fromStr);
            if (!parsedFrom) {
              await ctx.reply('‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã –Ω–∞—á–∞–ª–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç –î–î.–ú–ú[.–ì–ì–ì–ì].');
              return;
            }
            fromDate = parsedFrom;
          }

          if (!toStr || toStr === '') {
            await ctx.reply('‚ùå –ù–µ —É–∫–∞–∑–∞–Ω–∞ –¥–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç: /off [@username] [dateFrom-]dateTo');
            return;
          }

          const parsedTo = this.parseDate(toStr);
          if (!parsedTo) {
            await ctx.reply('‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã –æ–∫–æ–Ω—á–∞–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç –î–î.–ú–ú[.–ì–ì–ì–ì].');
            return;
          }
          toDate = parsedTo;
        } else {
          // Single date specified
          const parsedDate = this.parseDate(dateRange);
          if (!parsedDate) {
            await ctx.reply('‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç –î–î.–ú–ú[.–ì–ì–ì–ì] –∏–ª–∏ –î–î.–ú–ú-–î–î.–ú–ú –¥–ª—è –¥–∏–∞–ø–∞–∑–æ–Ω–∞.');
            return;
          }
          fromDate = new Date(parsedDate);
          toDate = new Date(parsedDate);
        }

        // Ensure fromDate is not after toDate
        if (fromDate > toDate) {
          await ctx.reply('‚ùå –î–∞—Ç–∞ –Ω–∞—á–∞–ª–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–∑–∂–µ –¥–∞—Ç—ã –æ–∫–æ–Ω—á–∞–Ω–∏—è.');
          return;
        }

        // Create the off record
        await this.offService.createOff(user.id, chatId, fromDate, toDate);

        // Format dates for display
        const fromStr = this.formatDate(fromDate);
        const toStr = this.formatDate(toDate);
        
        if (fromStr === toStr) {
          await ctx.reply(`‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –¥–ª—è @${username} –Ω–∞ ${fromStr}`);
        } else {
          await ctx.reply(`‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –¥–ª—è @${username} —Å ${fromStr} –ø–æ ${toStr}`);
        }

      } catch (error) {
        console.error('Error handling /off command:', error);
        await ctx.reply('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è.');
      }
    });

    // Handle /help command
    this.bot.command('help', async (ctx) => {
      const helpMessage = `
ü§ñ *–°–ø—Ä–∞–≤–∫–∞ MyDailyPlans Bot*

–≠—Ç–æ—Ç –±–æ—Ç –ø–æ–º–æ–≥–∞–µ—Ç –≤—Å–µ–º –±—ã—Ç—å –≤ –∫—É—Ä—Å–µ –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –ø–ª–∞–Ω–æ–≤ –∫–æ–º–∞–Ω–¥—ã.

*–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç:*
‚Ä¢ –ö–∞–∂–¥—ã–π —Ä–∞–±–æ—á–∏–π –¥–µ–Ω—å –≤ 6:00 GMT —è —Å–ø—Ä–∞—à–∏–≤–∞—é –æ –ø–ª–∞–Ω–∞—Ö –Ω–∞ –¥–µ–Ω—å.
‚Ä¢ –ü–æ–≤—Ç–æ—Ä–Ω—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –≤ 9:00, 12:00 –∏ 15:00 GMT –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏.
‚Ä¢ –Ø –æ—Ç—Å–ª–µ–∂–∏–≤–∞—é –æ—Ç–≤–µ—Ç—ã —Ç–æ–ª—å–∫–æ –æ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –∫–æ–º–∞–Ω–¥—ã.

*–ö–æ–º–∞–Ω–¥—ã:*
/status - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –∫—Ç–æ –æ—Ç–≤–µ—Ç–∏–ª —Å–µ–≥–æ–¥–Ω—è
/remind_pr - –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ PR –≤—Ä—É—á–Ω—É—é
/remind_duty - –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –æ –¥–µ–∂—É—Ä—Å—Ç–≤–µ
/off - –î–æ–±–∞–≤–∏—Ç—å –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ
/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É

*–ù–∞—Å—Ç—Ä–æ–π–∫–∞:*
‚Ä¢ –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–æ–≥–æ –±–æ—Ç–∞ –≤ –≤–∞—à –≥—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç.
‚Ä¢ –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.
      `;

      await ctx.reply(helpMessage, { parse_mode: 'Markdown' });
    });

    // Handle messages from tracked users (moved to bottom to not interfere with commands)
    this.bot.on('message:text', async (ctx) => {
      const userId = ctx.from?.id;
      const chatId = ctx.chat.id;
      const username = ctx.from?.username;
      const messageId = ctx.message.message_id;
      const messageText = ctx.message.text;

      if (!userId || !username || !messageText) return;

      try {
        // Check if this is a tracked user in this chat
        const isTracked = await this.userService.isUserActiveInChat(userId, chatId);

        if (isTracked) {
          await this.userService.upsertUser(userId, chatId, username);
        }

        // Only track replies from specified users in group chats
        if (isTracked && ctx.chat.type !== 'private') {
          const date = this.getCurrentDate();

          // Check if user has already replied today
          const hasReplied = await this.planService.hasUserReplied(chatId, date, userId);

          if (!hasReplied) {
            // Save the plan to database
            await this.planService.insertPlan(userId, chatId, date, messageId, messageText);
            console.log(`User ${userId} replied with daily plan in chat ${chatId} for date ${date}`);

            // Check if everyone has replied
            const trackedUserIds = await this.userService.getTrackedUserIdsForChat(chatId);
            const unrepliedUserIds = await this.planService.getUnrepliedUserIds(chatId, date, trackedUserIds);

            if (unrepliedUserIds.length === 0) {
              await ctx.reply('‚úÖ –û—Ç–ª–∏—á–Ω–æ! –í—Å–µ –ø–æ–¥–µ–ª–∏–ª–∏—Å—å —Å–≤–æ–∏–º–∏ –ø–ª–∞–Ω–∞–º–∏ –Ω–∞ –¥–µ–Ω—å.');
            }
          } else {
            // User already replied today, save additional plan but don't send confirmation
            await this.planService.insertPlan(userId, chatId, date, messageId, messageText);
            console.log(`User ${userId} sent additional daily plan in chat ${chatId} for date ${date}`);
          }
        }
      } catch (error) {
        console.error('Error handling message:', error);
      }
    });
  }

  private setupErrorHandling(): void {
    this.bot.catch((err) => {
      const ctx = err.ctx;
      console.error(`Error while handling update ${ctx.update.update_id}:`);
      const e = err.error;

      if (e instanceof GrammyError) {
        console.error('Error in request:', e.description);
      } else if (e instanceof HttpError) {
        console.error('Could not contact Telegram:', e);
      } else {
        console.error('Unknown error:', e);
      }
    });
  }

  private getCurrentDate(): string {
    return new Date().toISOString().split('T')[0];
  }

  /**
   * Parse date from DD.MM[.YYYY] format
   */
  private parseDate(dateStr: string): Date | null {
    // Remove any whitespace
    dateStr = dateStr.trim();
    
    // Split by dots
    const parts = dateStr.split('.');
    
    if (parts.length < 2 || parts.length > 3) {
      return null;
    }
    
    const day = parseInt(parts[0], 10);
    const month = parseInt(parts[1], 10);
    const year = parts.length === 3 ? parseInt(parts[2], 10) : new Date().getFullYear();
    
    // Validate values
    if (isNaN(day) || isNaN(month) || isNaN(year)) {
      return null;
    }
    
    if (day < 1 || day > 31 || month < 1 || month > 12 || year < 2000 || year > 2100) {
      return null;
    }
    
    // Create date (month is 0-indexed in JavaScript)
    const date = new Date(year, month - 1, day);
    
    // Check if the date is valid (e.g., not Feb 31)
    if (date.getDate() !== day || date.getMonth() !== month - 1 || date.getFullYear() !== year) {
      return null;
    }
    
    // Set time to start of day
    date.setHours(0, 0, 0, 0);
    
    return date;
  }

  /**
   * Format date to DD.MM.YYYY
   */
  private formatDate(date: Date): string {
    const day = date.getDate().toString().padStart(2, '0');
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const year = date.getFullYear();
    return `${day}.${month}.${year}`;
  }
} 